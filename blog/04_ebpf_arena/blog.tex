\documentclass{article}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{xcolor}

\title{eBPF Arena: A Tutorial}
\author{Farbod Shahinfar}
\begin{document}
\maketitle

\include{inc.tex}

As part of my research, I spend much time learning about eBPF.
Recently, I am busy exploring \emph{Arena} --- a new eBPF API that enables
programs to allocate memory pages; similar functionality as \C{mmap} and
\C{munmap}~\cite{arenapatch}.

The eBPF community is doing a great job documenting the system and writing
tutorials. I felt I could contribute to this effort by writing about Arena.

{
    \textcolor{red}{At the moment, this blog post is a \emph{work in
    progress} and I will update it as I learn more about Arena and figure
    things out.}
}

\section{Introduction}

The \emph{Arena} is a new MAP type (\bpfmap{arena}) available to eBPF programs
since kernel version 6.9.
This map is semantically different than previous ones.
Unlike data-structure MAPs (e.g., hash, array, bloom, stack, \dots{}) Arena
provides a direct access to the kernel memory instead of abstracting it away.
It increases the programs expressivity and enables them to implement their own
data-structures on-demand (e.g, a specific type of tree or a more optimized
version of hash-map).

Three use-cases have been named for the Arena in its patch introduction
message~\cite{arenapatch}. I summarize them bellow:
\begin{itemize}
    \item User-space can use Arena's memory to implement its own
        data-structures (it is a normal memory region), while the memory is
        visible to eBPF programs which can implement a fast-path for operations
        like packet processing.
    \item Arena can be used as a communication channel between an eBPF and a
        user-space program.
    \item Arena can be used as a \emph{heap} of memory for the eBPF program
\end{itemize}
My understanding from these use-cases is that Arena provides access to raw
pages of memory shareable among eBPF programs and user-space. Each can decide to
use it as they see fit with their own responsibility. It is unlike other types
of data-structure MAPs that enforce certain constraints such as fixed key and
value sizes while limited the operations to lookup and update.

In this tutorial, I try to explore Arena's API, and provide an example for each
use-case in the hope that it facilitates the journey of other in figuring out
how to use this new capability. The code snippets shown in this text is shared
on \href{https://github.com/bpf-endeavor/ebpf-arena-tutorial}{this repository}.

\section{Arena's API}

\subsection{Declare a MAP}
A program can declare the Arena map as other maps. See Listing~\ref{lst:map_ex}
for an example. The key size and value sizes must be zero. Max entries define
the maximum number of pages for the map, and must be non-zero. As any other
map, the maximum size is limited to 4~GB. At the time of writing this text,
Arena map declaration supports three flags~\cite{arena_source}:
\begin{itemize}
    \item \C{BPF_F_MMAPABLE}: \textbf{Required}. Indicates the map should
        support memory mapping.
    \item \C{BPF_F_SEGV_ON_FAULT}: The user-space program will receive a
        \C{SEGFAULT} signal if the memory is not mapped by the eBPF program
        (e.g., out of range access on a list created by the eBPF program).
    \item \C{BPF_F_NO_USER_CONV}: The memory region is private to the eBPF
        program and user-space program will not access it. This allows the JIT
        to perform optimizations avoiding address space casting (more about it
        later).
\end{itemize}
\textcolor{gray}{\textit{note: The \C{BPF_F_MMAPABLE} must always be present.}}

\begin{minipage}{\linewidth}
\centering
\begin{flushleft}
\begin{lstlisting}[caption={Example of using Arena map.}, label={lst:map_ex}]
struct {
    __uint(type, BPF_MAP_TYPE_ARENA);
    __uint(map_flags, BPF_F_MMAPABLE);
    __uint(max_entries, 2); /* number of pages */
} arena SEC(".maps");
\end{lstlisting}
\end{flushleft}
\end{minipage}

\subsection{Helper functions}
Normal eBPF map helpers such as ``\C{bpf_map_lookup_elem}'' are not
defined for Arena~\cite{arena_source}. Instead the following pair of functions
are available:
\begin{itemize}
    \item \C{bpf_arena_alloc_pages}: Allocates a memory page
    \item \C{bpf_arena_free_pages}: Free the memory page
\end{itemize}

These functions are defined using kfunc~\cite{eunomia_kfunc, ebpf_docs_kfunc}.
As required by kfunc subsystem, you should declare the signature of these
helpers in your eBPF program to hues these functions.
\begin{minipage}{\linewidth}
\begin{flushleft}
\begin{lstlisting}[caption={Functions operating on Arena MAP.}, label={lst:arena_kfuncs}]
void __arena* bpf_arena_alloc_pages(void *map, void __arena *addr,
    __u32 page_cnt, int node_id, __u64 flags) __ksym;
void bpf_arena_free_pages(void *map, void __arena *ptr,
    __u32 page_cnt) __ksym;
\end{lstlisting}
\end{flushleft}
\end{minipage}

Calling these functions may put the thread to sleep. For this reason the
functions are marked with \C{KF_SLEEPABLE}~\cite{arena_source}, and the
verifier only allows sleepable eBPF programs to use them. An eBPF program has
sleeping privilege if the \C{BPF_F_SLEEPABLE} flag was set when loading it
(see Listing~\ref{lst:loader} for an example).
Not all eBPF hooks support this flag. A list of sleepable
hooks are provided in \emph{libbpf} documentations~\cite{libbpf_sleepable}.

\textcolor{gray}{\emph{note: The memory pages allocated use following flags: \C{GFP_KERNEL}, \C{__GFP_ZERO}, \C{__GFP_ACCOUNT}.}}

\subsection{Managing two address spaces}

\emph{Clang} compiler, the verifier, the JIT, and the runtime all work together
to make sure the eBPF program accesses the correct memory address. When using
Arena there is a translation between the user address space and kernel address
space (unless the map is declared with ``\C{BPF_F_NO_USER_CONV}'' flag
present). The eBPF program must mark the pointers with
``\C{__attribute__((address_space(1)))}'' to let the Clang know about it and
cause the generation of ``\C{bpf_arena_cast_user/kern}'' instrucitons. The
``\C{__arena}'' used in declaration of variables and parameters bears this
purpose.

\textcolor{gray}{\emph{note: if this explanation is vague, it is because I need
to learn more about it.}}



\section{Examples}

I try to demonstrate how these APIs can be used to implement the use-cases named
above.

\subsection{Memory shared among eBPF and user-space}

As a first step, I try to share a counter between an eBPF program and the
user-space. Let us define a eBPF program of type
\C{BPF_PROT_TYPE_SYSCALL}~\cite{ebpf_docs_prog_syscall} which does not need to
be attached to a hook and instead is invoked using the \C{BPF_PROG_TEST_RUN}
system call~\cite{ebpf_docs_bpf_prog_run}.

Listing~\ref{lst:mogu} demonstrates an eBPF program using Arena. In this
program, a global variable (``\C{flag_initialized}'') tracks if it is the first
time the program is invoked or not. At the first invocation a page is allocated
and its address is kept in ``\C{mem}'' global variable. The allocated memory
will hold a counter keeping the number of invocations.

\textcolor{gray}{\textit{note: The global variable support is available since kernel version 5.2~\cite{glb_var_post}.}}

\begin{minipage}{\linewidth}
\begin{flushleft}
\begin{lstlisting}[caption={An eBPF program using Arena.}, label={lst:mogu}]
static bool flag_initialized = false;
__arena void *mem = NULL;
SEC("syscall")
int mogu_main(void *_)
{
    bpf_printk("mogu: hello\n");
    if (!flag_initialized) {
        mem = bpf_arena_alloc_pages(&arena, NULL, 1, NUMA_NO_NODE, 0);
        if (mem == NULL) {
            bpf_printk("Failed to allocate memory");
            return 1;
        }
        flag_initialized = true;
    }
    if (mem == NULL) {
        /* this branch must never happen! */
        return 1;
    }
    __arena entry_t *e = mem;
    e->counter += 1;
    bpf_printk("counter: %lld\n", e->counter);
    return 0;
}
\end{lstlisting}
\end{flushleft}
\end{minipage}

Next, in Listing~\ref{lst:loader}, we see how user-space program loads the eBPF
program and Listing~\ref{lst:loader_read} shows it accessing the counter on the
Arena memory page. The user-space program relies on skeleton objects from
libbpf~\cite{libbpf_skeleton}.

\begin{minipage}{\linewidth}
\begin{flushleft}
\begin{lstlisting}[caption={User space program loading the program}, label={lst:loader}]
/* Some global vars */
static volatile int running = 0;
static int ebpf_prog_fd = -1;
static struct mogu *skel = NULL;

int main(int argc, char *argv[])
{
    skel = mogu__open();
    if (!skel) {
        fprintf(stderr, "Failed to open the skeleton\n");
        return EXIT_FAILURE;
    }
    /* Set sleepable flag */
    bpf_program__set_flags(skel->progs.mogu_main, BPF_F_SLEEPABLE);
    if (mogu__load(skel)) {
        fprintf(stderr, "Failed to load eBPF program\n");
        return EXIT_FAILURE;
    }

    ebpf_prog_fd = bpf_program__fd(skel->progs.mogu_main);
    /* It will invoke the eBPF program for the first time */
    handle_invoke_signal(0);

    /* Keep running and handle signals */
    running = 1;
    signal(SIGINT, handle_signal);
    signal(SIGHUP, handle_signal);
    signal(SIGUSR1, handle_invoke_signal);
    printf("Hit Ctrl+C to terminate ...\n");
    printf("Invoke eBPF program:\n");
    printf("\tMogu: pkill -SIGUSR1 mogu_loader\n");

    while (running) { pause(); }

    mogu__detach(skel);
    mogu__destroy(skel);
    printf("Done!\n");
    return 0;
}
\end{lstlisting}
\end{flushleft}
\end{minipage}

\begin{minipage}{\linewidth}
\begin{flushleft}
\begin{lstlisting}[caption={User-space accessing the memory page allocated from
Arena}, label={lst:loader_read}]
entry_t *e = skel->bss->mem;
if (e == NULL) {
    printf("NOTE: the initialization was not successful!\n");
    return;
}
printf("user: counter=%lld\n", e->counter);
\end{lstlisting}
\end{flushleft}
\end{minipage}


\subsection{Memory shared among two eBPF programs}

\dots{}


\bibliographystyle{plain}
\bibliography{ref}
\end{document}
