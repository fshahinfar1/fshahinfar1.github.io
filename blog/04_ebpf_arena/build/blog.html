<!DOCTYPE html> 
<html lang="en-US" xml:lang="en-US" > 
<head><title>eBPF Arena: A Tutorial</title> 
<meta  charset="utf-8" /> 
<meta name="generator" content="TeX4ht (https://tug.org/tex4ht/)" /> 
<meta name="viewport" content="width=device-width,initial-scale=1" /> 
<link rel="stylesheet" type="text/css" href="blog.css" /> 
<meta name="src" content="blog.tex" /> 
</head><body 
>
   <div class="maketitle">
                                                                  

                                                                  
                                                                  

                                                                  

<h2 class="titleHead">eBPF Arena: A Tutorial</h2>
<div class="author" ><span 
class="cmr-12">Farbod Shahinfar</span></div><br />
<div class="date" ><span 
class="cmr-12">February 8, 2025</span></div>
   </div>
                                                                  

                                                                  
   <title>eBPF Arena: A Tutorial</title> 
<meta  charset="utf-8" /> 
<meta name="generator" content="TeX4ht (https://tug.org/tex4ht/)" /> 
<meta name="viewport" content="width=device-width,initial-scale=1" /> 
<link rel="stylesheet" type="text/css" href="blog.css" /> 
<meta name="src" content="blog.tex" /> 
</head><body 
>
                                                                  

                                                                  
                                                                  

                                                                  
<!--l. 14--><p class="indent" >   As part of my research, I spend much time learning about eBPF. Recently, I am
busy exploring Arena — a new eBPF API that enables programs to allocate memory
pages; similar functionality as mmap and munmap <span class="cite">[<a 
href="#Xarenapatch">9</a>]</span>.
</p><!--l. 19--><p class="indent" >   The eBPF community is doing a great job documenting the system and
writing tutorials. I felt I could contribute to this effort by writing about
Arena.
</p><!--l. 25--><p class="indent" >   <span id="textcolor1">At the moment, this blog post is a work in progress and I will update it as I learn
more about Arena and figure things out.</span>
</p>
   <h3 class="sectionHead"><span class="titlemark">1   </span> <a 
 id="x1-10001"></a>Introduction</h3>
<!--l. 30--><p class="noindent" >The Arena is a new MAP type (BPF_MAP_TYPE_ARENA) available to eBPF programs
since kernel version 6.9. This map is semantically different than previous
ones. Unlike data-structure MAPs (e.g., hash, array, bloom, stack, …) Arena
provides a direct access to the kernel memory instead of abstracting it away. It
increases the programs expressivity and enables them to implement their own
data-structures on-demand (e.g, a specific type of tree or a more optimized version of
hash-map).
</p><!--l. 39--><p class="indent" >   Three use-cases have been named for the Arena in its patch introduction
message <span class="cite">[<a 
href="#Xarenapatch">9</a>]</span>. I summarize them bellow: </p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 42--><p class="noindent" >User-space can use Arena’s memory to implement its own data-structures
     (it is a normal memory region), while the memory is visible to eBPF
     programs  which  can  implement  a  fast-path  for  operations  like  packet
     processing.
     </p></li>
     <li class="itemize">
     <!--l. 46--><p class="noindent" >Arena can be used as a communication channel between an eBPF and a
     user-space program.
     </p></li>
     <li class="itemize">
     <!--l. 48--><p class="noindent" >Arena can be used as a heap of memory for the eBPF program</p></li></ul>
<!--l. 50--><p class="noindent" >My understanding from these use-cases is that Arena provides access to raw pages of
memory shareable among eBPF programs and user-space. Each can decide to use it
as they see fit with their own responsibility. It is unlike other types of data-structure
MAPs that enforce certain constraints such as fixed key and value sizes while limited
the operations to lookup and update.
</p><!--l. 56--><p class="indent" >   In this tutorial, I try to explore Arena’s API, and provide an example for each
use-case in the hope that it facilitates the journey of other in figuring out how to use
                                                                  

                                                                  
this new capability. The code snippets shown in this text is shared on <a 
href="https://github.com/bpf-endeavor/ebpf-arena-tutorial" target="_blank" >this
repository</a>.
</p><!--l. 61--><p class="noindent" >
</p>
   <h3 class="sectionHead"><span class="titlemark">2   </span> <a 
 id="x1-20002"></a>Arena’s API</h3>
<!--l. 63--><p class="noindent" >
</p>
   <h4 class="subsectionHead"><span class="titlemark">2.1   </span> <a 
 id="x1-30002.1"></a>Declare a MAP</h4>
<!--l. 64--><p class="noindent" >A program can declare the Arena map as other maps. See Listing <a 
href="#x1-3001r1">1<!--tex4ht:ref: lst:map_ex --></a> for an example.
The key size and value sizes must be zero. Max entries define the maximum number
of pages for the map, and must be non-zero. As any other map, the maximum size is
limited to 4 GB. At the time of writing this text, Arena map declaration supports
three flags <span class="cite">[<a 
href="#Xarena_source">4</a>]</span>: </p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 70--><p class="noindent" >BPF_F_MMAPABLE: Required. Indicates the map should support memory
     mapping.
     </p></li>
     <li class="itemize">
     <!--l. 72--><p class="noindent" >BPF_F_SEGV_ON_FAULT: The user-space program will receive a SEGFAULT
     signal if the memory is not mapped by the eBPF program (e.g., out of
     range access on a list created by the eBPF program).
     </p></li>
     <li class="itemize">
     <!--l. 75--><p class="noindent" >BPF_F_NO_USER_CONV: The memory region is private to the eBPF program
     and user-space program will not access it. This allows the JIT to perform
     optimizations avoiding address space casting (more about it later).</p></li></ul>
<!--l. 80--><p class="noindent" ><span id="textcolor2">note: The BPF_F_MMAPABLE must always be present.</span>
</p>
   <div class="minipage"><div class="flushleft" 
>
<!--l. 84--><p class="noindent" >
 </p><!--l. 85-->
<a 
 id="x1-3001r1"></a>
<a 
 id="x1-3002"></a>
<div class="lstlisting" id="listing-1"><span class="label"><a 
 id="x1-3003r1"></a>1</span>struct { <br /> 
<span class="label"><a 
 id="x1-3004r2"></a>2</span>    __uint(type, BPF_MAP_TYPE_ARENA); <br /> 
<span class="label"><a 
 id="x1-3005r3"></a>3</span>    __uint(map_flags, BPF_F_MMAPABLE); <br /> 
<span class="label"><a 
 id="x1-3006r4"></a>4</span>    __uint(max_entries, 2); /* number of pages */ <br /> 
<span class="label"><a 
 id="x1-3007r5"></a>5</span>} arena SEC(&#x0022;.maps&#x0022;);</div>
<figcaption class="caption" ><span class="id">Listing 1:</span><span  
class="content">Example of using Arena map.</span></figcaption><!--tex4ht:label?: x1-3001r2 -->
</div></div>
                                                                  

                                                                  
<!--l. 95--><p class="noindent" >
</p>
   <h4 class="subsectionHead"><span class="titlemark">2.2   </span> <a 
 id="x1-40002.2"></a>Helper functions</h4>
<!--l. 96--><p class="noindent" >Normal eBPF map helpers such as “bpf_map_lookup_elem” are not defined for
Arena <span class="cite">[<a 
href="#Xarena_source">4</a>]</span>. Instead the following pair of functions are available: </p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 100--><p class="noindent" >bpf_arena_alloc_pages: Allocates a memory page
     </p></li>
     <li class="itemize">
     <!--l. 101--><p class="noindent" >bpf_arena_free_pages: Free the memory page</p></li></ul>
<!--l. 104--><p class="indent" >   These functions are defined using kfunc <span class="cite">[<a 
href="#Xeunomia_kfunc">3</a>, <a 
href="#Xebpf_docs_kfunc">2</a>]</span>. As required by kfunc subsystem,
you should declare the signature of these helpers in your eBPF program to hues these
functions. </p><div class="minipage"><div class="flushleft" 
>
<!--l. 108--><p class="noindent" >
 </p><!--l. 109-->
<a 
 id="x1-4001r2"></a>
<a 
 id="x1-4002"></a>
<div class="lstlisting" id="listing-2"><span class="label"><a 
 id="x1-4003r1"></a>1</span>void __arena* bpf_arena_alloc_pages(void *map, void __arena *addr, <br /> 
<span class="label"><a 
 id="x1-4004r2"></a>2</span>    __u32 page_cnt, int node_id, __u64 flags) __ksym; <br /> 
<span class="label"><a 
 id="x1-4005r3"></a>3</span>void bpf_arena_free_pages(void *map, void __arena *ptr, <br /> 
<span class="label"><a 
 id="x1-4006r4"></a>4</span>    __u32 page_cnt) __ksym;</div>
<figcaption class="caption" ><span class="id">Listing 2:</span><span  
class="content">Functions operating on Arena MAP.</span></figcaption><!--tex4ht:label?: x1-4001r2 -->
</div></div>
<!--l. 118--><p class="indent" >   Calling these functions may put the thread to sleep. For this reason the functions
are marked with KF_SLEEPABLE <span class="cite">[<a 
href="#Xarena_source">4</a>]</span>, and the verifier only allows sleepable
eBPF programs to use them. An eBPF program has sleeping privilege if the
BPF_F_SLEEPABLE flag was set when loading it (see Listing <a 
href="#x1-7026r4">4<!--tex4ht:ref: lst:loader --></a> for an example). Not all
eBPF hooks support this flag. A list of sleepable hooks are provided in libbpf
documentations <span class="cite">[<a 
href="#Xlibbpf_sleepable">6</a>]</span>.
</p><!--l. 126--><p class="indent" >   <span id="textcolor3">note: The memory pages allocated use following flags: GFP_KERNEL, __GFP_ZERO,
__GFP_ACCOUNT.</span>
</p><!--l. 128--><p class="noindent" >
</p>
   <h4 class="subsectionHead"><span class="titlemark">2.3   </span> <a 
 id="x1-50002.3"></a>Managing two address spaces</h4>
<!--l. 130--><p class="noindent" >Clang compiler, the verifier, the JIT, and the runtime all work together to make sure
the eBPF program accesses the correct memory address. When using Arena there is a
translation between the user address space and kernel address space (unless the map
is declared with “BPF_F_NO_USER_CONV” flag present). The eBPF program must
mark the pointers with “__attribute__((address_space(1)))” to let the Clang
know about it and cause the generation of “bpf_arena_cast_user/kern”
instrucitons. The “__arena” used in declaration of variables and parameters bears
this purpose.
                                                                  

                                                                  
</p><!--l. 141--><p class="indent" >   <span id="textcolor4">note: if this explanation is vague, it is because I need to learn more about
it.</span>
</p><!--l. 145--><p class="noindent" >
</p>
   <h3 class="sectionHead"><span class="titlemark">3   </span> <a 
 id="x1-60003"></a>Examples</h3>
<!--l. 147--><p class="noindent" >I try to demonstrate how these APIs can be used to implement the use-cases named
above.
</p><!--l. 150--><p class="noindent" >
</p>
   <h4 class="subsectionHead"><span class="titlemark">3.1   </span> <a 
 id="x1-70003.1"></a>Memory shared among eBPF and user-space</h4>
<!--l. 152--><p class="noindent" >As a first step, I try to share a counter between an eBPF program and the
user-space. Let us define a eBPF program of type BPF_PROT_TYPE_SYSCALL <span class="cite">[<a 
href="#Xebpf_docs_prog_syscall">8</a>]</span> which
does not need to be attached to a hook and instead is invoked using the
BPF_PROG_TEST_RUN system call <span class="cite">[<a 
href="#Xebpf_docs_bpf_prog_run">7</a>]</span>.
</p><!--l. 158--><p class="indent" >   Listing <a 
href="#x1-7001r3">3<!--tex4ht:ref: lst:mogu --></a> demonstrates an eBPF program using Arena. In this program, a global
variable (“flag_initialized”) tracks if it is the first time the program is invoked or
not. At the first invocation a page is allocated and its address is kept in “mem” global
variable. The allocated memory will hold a counter keeping the number of
invocations.
</p><!--l. 164--><p class="indent" >   <span id="textcolor5">note: The global variable support is available since kernel version 5.2 <span class="cite">[<a 
href="#Xglb_var_post">1</a>]</span>.</span>
</p>
   <div class="minipage"><div class="flushleft" 
>
<!--l. 167--><p class="noindent" >
 </p><!--l. 168-->
<a 
 id="x1-7001r3"></a>
<a 
 id="x1-7002"></a>
<div class="lstlisting" id="listing-3"><span class="label"><a 
 id="x1-7003r1"></a>1</span>static bool flag_initialized = false; <br /> 
<span class="label"><a 
 id="x1-7004r2"></a>2</span>__arena void *mem = NULL; <br /> 
<span class="label"><a 
 id="x1-7005r3"></a>3</span>SEC(&#x0022;syscall&#x0022;) <br /> 
<span class="label"><a 
 id="x1-7006r4"></a>4</span>int mogu_main(void *_) <br /> 
<span class="label"><a 
 id="x1-7007r5"></a>5</span>{ <br /> 
<span class="label"><a 
 id="x1-7008r6"></a>6</span>    bpf_printk(&#x0022;mogu: hello\n&#x0022;); <br /> 
<span class="label"><a 
 id="x1-7009r7"></a>7</span>    if (!flag_initialized) { <br /> 
<span class="label"><a 
 id="x1-7010r8"></a>8</span>        mem = bpf_arena_alloc_pages(&#x0026;arena, NULL, 1, NUMA_NO_NODE, 0); <br /> 
<span class="label"><a 
 id="x1-7011r9"></a>9</span>        if (mem == NULL) { <br /> 
<span class="label"><a 
 id="x1-7012r10"></a>10</span>            bpf_printk(&#x0022;Failed to allocate memory&#x0022;); <br /> 
<span class="label"><a 
 id="x1-7013r11"></a>11</span>            return 1; <br /> 
<span class="label"><a 
 id="x1-7014r12"></a>12</span>        } <br /> 
<span class="label"><a 
 id="x1-7015r13"></a>13</span>        flag_initialized = true; <br /> 
<span class="label"><a 
 id="x1-7016r14"></a>14</span>    } <br /> 
<span class="label"><a 
 id="x1-7017r15"></a>15</span>    if (mem == NULL) { <br /> 
<span class="label"><a 
 id="x1-7018r16"></a>16</span>        /* this branch must never happen! */ <br /> 
<span class="label"><a 
 id="x1-7019r17"></a>17</span>        return 1; <br /> 
<span class="label"><a 
 id="x1-7020r18"></a>18</span>    } <br /> 
<span class="label"><a 
 id="x1-7021r19"></a>19</span>    __arena entry_t *e = mem; <br /> 
<span class="label"><a 
 id="x1-7022r20"></a>20</span>    e-&#x003E;counter += 1; <br /> 
<span class="label"><a 
 id="x1-7023r21"></a>21</span>    bpf_printk(&#x0022;counter: %lld\n&#x0022;, e-&#x003E;counter); <br /> 
<span class="label"><a 
 id="x1-7024r22"></a>22</span>    return 0; <br /> 
<span class="label"><a 
 id="x1-7025r23"></a>23</span>}</div>
<figcaption class="caption" ><span class="id">Listing 3:</span><span  
class="content">An eBPF program using Arena.</span></figcaption><!--tex4ht:label?: x1-7001r3 -->
</div></div>
<!--l. 196--><p class="indent" >   Next, in Listing <a 
href="#x1-7026r4">4<!--tex4ht:ref: lst:loader --></a>, we see how user-space program loads the eBPF program and
Listing <a 
href="#x1-7067r5">5<!--tex4ht:ref: lst:loader_read --></a> shows it accessing the counter on the Arena memory page. The user-space
program relies on skeleton objects from libbpf <span class="cite">[<a 
href="#Xlibbpf_skeleton">5</a>]</span>.
</p>
                                                                  

                                                                  
   <div class="minipage"><div class="flushleft" 
>
<!--l. 202--><p class="noindent" >
 </p><!--l. 203-->
<a 
 id="x1-7026r4"></a>
<a 
 id="x1-7027"></a>
<div class="lstlisting" id="listing-4"><span class="label"><a 
 id="x1-7028r1"></a>1</span>/* Some global vars */ <br /> 
<span class="label"><a 
 id="x1-7029r2"></a>2</span>static volatile int running = 0; <br /> 
<span class="label"><a 
 id="x1-7030r3"></a>3</span>static int ebpf_prog_fd = -1; <br /> 
<span class="label"><a 
 id="x1-7031r4"></a>4</span>static struct mogu *skel = NULL; <br /> 
<span class="label"><a 
 id="x1-7032r5"></a>5</span> <br /> 
<span class="label"><a 
 id="x1-7033r6"></a>6</span>int main(int argc, char *argv[]) <br /> 
<span class="label"><a 
 id="x1-7034r7"></a>7</span>{ <br /> 
<span class="label"><a 
 id="x1-7035r8"></a>8</span>    skel = mogu__open(); <br /> 
<span class="label"><a 
 id="x1-7036r9"></a>9</span>    if (!skel) { <br /> 
<span class="label"><a 
 id="x1-7037r10"></a>10</span>        fprintf(stderr, &#x0022;Failed to open the skeleton\n&#x0022;); <br /> 
<span class="label"><a 
 id="x1-7038r11"></a>11</span>        return EXIT_FAILURE; <br /> 
<span class="label"><a 
 id="x1-7039r12"></a>12</span>    } <br /> 
<span class="label"><a 
 id="x1-7040r13"></a>13</span>    /* Set sleepable flag */ <br /> 
<span class="label"><a 
 id="x1-7041r14"></a>14</span>    bpf_program__set_flags(skel-&#x003E;progs.mogu_main, BPF_F_SLEEPABLE); <br /> 
<span class="label"><a 
 id="x1-7042r15"></a>15</span>    if (mogu__load(skel)) { <br /> 
<span class="label"><a 
 id="x1-7043r16"></a>16</span>        fprintf(stderr, &#x0022;Failed to load eBPF program\n&#x0022;); <br /> 
<span class="label"><a 
 id="x1-7044r17"></a>17</span>        return EXIT_FAILURE; <br /> 
<span class="label"><a 
 id="x1-7045r18"></a>18</span>    } <br /> 
<span class="label"><a 
 id="x1-7046r19"></a>19</span> <br /> 
<span class="label"><a 
 id="x1-7047r20"></a>20</span>    ebpf_prog_fd = bpf_program__fd(skel-&#x003E;progs.mogu_main); <br /> 
<span class="label"><a 
 id="x1-7048r21"></a>21</span>    /* It will invoke the eBPF program for the first time */ <br /> 
<span class="label"><a 
 id="x1-7049r22"></a>22</span>    handle_invoke_signal(0); <br /> 
<span class="label"><a 
 id="x1-7050r23"></a>23</span> <br /> 
<span class="label"><a 
 id="x1-7051r24"></a>24</span>    /* Keep running and handle signals */ <br /> 
<span class="label"><a 
 id="x1-7052r25"></a>25</span>    running = 1; <br /> 
<span class="label"><a 
 id="x1-7053r26"></a>26</span>    signal(SIGINT, handle_signal); <br /> 
<span class="label"><a 
 id="x1-7054r27"></a>27</span>    signal(SIGHUP, handle_signal); <br /> 
<span class="label"><a 
 id="x1-7055r28"></a>28</span>    signal(SIGUSR1, handle_invoke_signal); <br /> 
<span class="label"><a 
 id="x1-7056r29"></a>29</span>    printf(&#x0022;Hit Ctrl+C to terminate ...\n&#x0022;); <br /> 
<span class="label"><a 
 id="x1-7057r30"></a>30</span>    printf(&#x0022;Invoke eBPF program:\n&#x0022;); <br /> 
<span class="label"><a 
 id="x1-7058r31"></a>31</span>    printf(&#x0022;\tMogu: pkill -SIGUSR1 mogu_loader\n&#x0022;); <br /> 
<span class="label"><a 
 id="x1-7059r32"></a>32</span> <br /> 
<span class="label"><a 
 id="x1-7060r33"></a>33</span>    while (running) { pause(); } <br /> 
<span class="label"><a 
 id="x1-7061r34"></a>34</span> <br /> 
<span class="label"><a 
 id="x1-7062r35"></a>35</span>    mogu__detach(skel); <br /> 
<span class="label"><a 
 id="x1-7063r36"></a>36</span>    mogu__destroy(skel); <br /> 
<span class="label"><a 
 id="x1-7064r37"></a>37</span>    printf(&#x0022;Done!\n&#x0022;); <br /> 
<span class="label"><a 
 id="x1-7065r38"></a>38</span>    return 0; <br /> 
<span class="label"><a 
 id="x1-7066r39"></a>39</span>}</div>
<figcaption class="caption" ><span class="id">Listing 4:</span><span  
class="content">User space program loading the program</span></figcaption><!--tex4ht:label?: x1-7026r3 -->
</div></div>
   <div class="minipage"><div class="flushleft" 
>
<!--l. 248--><p class="noindent" >
 </p><!--l. 249-->
<a 
 id="x1-7067r5"></a>
<a 
 id="x1-7068"></a>
<div class="lstlisting" id="listing-5"><span class="label"><a 
 id="x1-7069r1"></a>1</span>entry_t *e = skel-&#x003E;bss-&#x003E;mem; <br /> 
<span class="label"><a 
 id="x1-7070r2"></a>2</span>if (e == NULL) { <br /> 
<span class="label"><a 
 id="x1-7071r3"></a>3</span>    printf(&#x0022;NOTE: the initialization was not successful!\n&#x0022;); <br /> 
<span class="label"><a 
 id="x1-7072r4"></a>4</span>    return; <br /> 
<span class="label"><a 
 id="x1-7073r5"></a>5</span>} <br /> 
<span class="label"><a 
 id="x1-7074r6"></a>6</span>printf(&#x0022;user: counter=%lld\n&#x0022;, e-&#x003E;counter);</div>
<figcaption class="caption" ><span class="id">Listing 5:</span><span  
class="content">User-space accessing the memory page allocated from Arena</span></figcaption><!--tex4ht:label?: x1-7067r3 -->
</div></div>
<!--l. 262--><p class="noindent" >
</p>
   <h4 class="subsectionHead"><span class="titlemark">3.2   </span> <a 
 id="x1-80003.2"></a>Memory shared among two eBPF programs</h4>
<!--l. 264--><p class="noindent" >…
</p><!--l. 1--><p class="noindent" >
</p>
   <h3 class="likesectionHead"><a 
 id="x1-90003.2"></a>References</h3>
<!--l. 1--><p class="noindent" >
   </p><div class="thebibliography">
   <p class="bibitem" ><span class="biblabel">
 [1]<span class="bibsp">   </span></span><a 
 id="Xglb_var_post"></a>Johannes     Bechberger.             Hello     ebpf:     Global     variables.
   <a 
href="https://mostlynerdless.de/blog/2024/05/21/hello-ebpf-global-variables-10/" class="url" >https://mostlynerdless.de/blog/2024/05/21/hello-ebpf-global-variables-10/</a>,
   2024.
   </p>
   <p class="bibitem" ><span class="biblabel">
 [2]<span class="bibsp">   </span></span><a 
 id="Xebpf_docs_kfunc"></a>Silvano Cirujano Cuesta and Dylan Reimerink.  ebpf documentations:
   kfuncs.     <a 
href="https://docs.ebpf.io/linux/concepts/kfuncs/" class="url" >https://docs.ebpf.io/linux/concepts/kfuncs/</a>, 2024.
   </p>
   <p class="bibitem" ><span class="biblabel">
 [3]<span class="bibsp">   </span></span><a 
 id="Xeunomia_kfunc"></a>Extending  ebpf  beyond  its  limits:  Custom  kfuncs  in  kernel  modules.
   <a 
href="https://eunomia.dev/tutorials/43-kfuncs/" class="url" >https://eunomia.dev/tutorials/43-kfuncs/</a>, 2024.
                                                                  

                                                                  
   </p>
   <p class="bibitem" ><span class="biblabel">
 [4]<span class="bibsp">   </span></span><a 
 id="Xarena_source"></a>Linux        source        tree:        Arena        map        implementation.
   <a 
href="https://elixir.bootlin.com/linux/v6.13.1/source/kernel/bpf/arena.c" class="url" >https://elixir.bootlin.com/linux/v6.13.1/source/kernel/bpf/arena.c</a>.
   </p>
   <p class="bibitem" ><span class="biblabel">
 [5]<span class="bibsp">   </span></span><a 
 id="Xlibbpf_skeleton"></a>Kernel  documentations:  Libbpf  overview:  Bpf  object  skeleton  file.
   <a 
href="https://docs.kernel.org/bpf/libbpf/libbpf_overview.html#bpf-object-skeleton-file" class="url" >https://docs.kernel.org/bpf/libbpf/libbpf_overview.html#bpf-object-skeleton-file</a>,
   2024.
   </p>
   <p class="bibitem" ><span class="biblabel">
 [6]<span class="bibsp">   </span></span><a 
 id="Xlibbpf_sleepable"></a>Andrii     Nakryiko,     Donald     Hunter,     and     Daan     De Meyer.
   libbpf      documentation:      Program      types      and      elf      sections.
   <a 
href="https://github.com/libbpf/libbpf/blob/master/docs/program_types.rst" class="url" >https://github.com/libbpf/libbpf/blob/master/docs/program_types.rst</a>.
   </p>
   <p class="bibitem" ><span class="biblabel">
 [7]<span class="bibsp">   </span></span><a 
 id="Xebpf_docs_bpf_prog_run"></a>Dylan
   Reimerink. ebpf documentations: Bpf syscall bpf_prog_test_run command.
   <a 
href="https://docs.ebpf.io/linux/syscall/BPF_PROG_TEST_RUN/" class="url" >https://docs.ebpf.io/linux/syscall/BPF_PROG_TEST_RUN/</a>, 2023.
   </p>
   <p class="bibitem" ><span class="biblabel">
 [8]<span class="bibsp">   </span></span><a 
 id="Xebpf_docs_prog_syscall"></a>Dylan   Reimerink.      ebpf   documentations:   Bpf_prog_type_syscall.
   <a 
href="https://docs.ebpf.io/linux/program-type/BPF_PROG_TYPE_SYSCALL/" class="url" >https://docs.ebpf.io/linux/program-type/BPF_PROG_TYPE_SYSCALL/</a>,
   2023.
   </p>
   <p class="bibitem" ><span class="biblabel">
 [9]<span class="bibsp">   </span></span><a 
 id="Xarenapatch"></a>Alex        Starovoitov.                       Introduce        bpf        arena.
   <a 
href="https://lwn.net/Articles/961594/" class="url" >https://lwn.net/Articles/961594/</a>, 2024.
</p>
   </div>
    
</body> 
</html>
                                                                  


